#!/bin/bash

printf2() {
    printf "$@" >&2
}

print() {
    printf '%s\n' "$@"
}

strip() {
    sed 's/\x1b\[[0-9;]*[a-zA-Z]//g'
}

clear() {
    printf2 '\e[?25l\e[u\e[J'
}

match() {
    GREP_COLORS=mt=4 command grep --color=always -Fif <(print "$@") | sed 's/\x1b\[m/\x1b[24m/g'
}

init() {
    stty=$(stty -F "$device" -g)
    stty -F "$device" -echo raw
    printf2 '\e[?25l'
    for ((i=0; i<$lines; i++)); do
        printf2 '\n\e[G'
    done
    printf2 '\e[%dF' $lines
    printf2 '\e[s'
    trap quit INT QUIT TERM
}

quit() {
    clear
    printf2 '\e[?25h'
    stty -F "$device" "$stty"
    if [ $# -eq 0 ]; then
        exit 1
    else
        print "$@" | strip
        exit 0
    fi
}

declare device=/dev/tty
declare lines=9
declare prompt='> '

declare -a input
declare -a items
declare -a matches
declare -A history

while getopts ':i:l:p:' opt; do
    case $opt in
        i)
            input=("$OPTARG" "${input[@]}")
            ;;
        l)
            lines=$OPTARG
            ;;
        p)
            prompt=$OPTARG
            ;;
        \?)
            exit 1
            ;;
    esac
done

init

IFS=$'\n' read -a items -d '' -r

if [ ${#items[@]} -eq 0 ]; then
    quit
fi

declare columns=$(tput cols)
declare index=0
declare point=${#input}
declare threshold=$((${#items[@]} / 5000))
declare tick=-1

while :; do
    # constrain point
    if [ $point -gt ${#input} ]; then
        point=${#input}
    elif [ $point -lt 0 ]; then
        point=0
    fi

    # constrain index
    if [ ${#matches[@]} -eq 0 ]; then
        index=0
    elif [ $index -lt 0 ]; then
        ((index+=${#matches[@]}))
    else
        ((index%=${#matches[@]}))
    fi

    # perform match
    if [ ${#input[@]} -ne $tick ]; then
        if [ ${#input} -lt $threshold ]; then
            matches=()
        elif [ ${#input} -eq 0 ]; then
            matches=("${items[@]}")
        elif [[ -n ${history[$input]:+_} ]]; then
            IFS=$'\n' matches=(${history[$input]})
        elif [ ${#input[@]} -eq 1 ] || [[ $input != ${input[1]}* ]] || [ ${#input} -eq $threshold ]; then
            IFS=$'\n' matches=($(print "${items[@]}" | match "$input"))
            history[$input]=$(print "${matches[@]}")
        else
            # TODO gzip history?
            IFS=$'\n' matches=($(print "${matches[@]}" | strip | match "$input"))
            history[$input]=$(print "${matches[@]}")
        fi
        index=0
        tick=${#input[@]}
    fi

    # draw menu
    clear
    printf2 '\e[?25l'
    printf2 '%s%s %d/%d/%d' "$prompt" "$input" $((index + 1)) ${#matches[@]} ${#items[@]}
    for ((i=0; i<$lines; i++)); do
        match=${matches[$i + $index]}
        match=${match::$columns}
        printf2 '\e[E'
        if [ $i -eq 0 ]; then
            printf2 '\e[7m%s\e[27m' "$match"
        else
            printf2 '%s' "$match"
        fi
    done
    printf2 '\e[u\e[%dG\e[?25h' $((${#prompt} + point + 1))

    # read input
    read -n 1 -r -s < "$device"
    case $REPLY in
        # exit
        # C-g/ESC
        $'\007'|$'\033') quit;;
        # RET
        '')
            if [ $index -lt ${#matches[@]} ]; then
                quit "${matches[$index]}"
            else
                quit
            fi
            ;;

        # cursor movement
        # C-b
        $'\002') ((point--));;
        # C-f
        $'\006') ((point++));;
        # C-a
        $'\001') point=0;;
        # C-e
        $'\005') point=${#input};;

        # line movement
        # C-n/C-r
        $'\016'|$'\022') ((index++));;
        # C-p/C-s
        $'\020'|$'\023') ((index--));;

        # deletion
        # C-k
        $'\v')   input=("${input::$point}" "${input[@]}");;
        # C-u
        $'\025') input=('' "${input[@]}");;
        # C-d
        $'\004') input=("${input::$point}${input:$((point + 1))}" "${input[@]}");;
        # DEL
        $'\177')
            if [[ -n $input ]]; then
                input=("${input::-1}" "${input[@]}")
                ((point--))
            fi
            ;;

        # undo
        # C-_
        $'\037')
            input=("${input[@]:1}")
            point=${#input}
            ;;

        # restrict
        # C-l
        $'\f')
            IFS=$'\n' items=($(print "${matches[@]}" | strip))
            input=()
            history=()
            ;;

        # insertion
        # TAB
        $'\t')
            if [ $index -lt ${#matches[@]} ]; then
                input=("$(strip <<< "${matches[$index]}")" "${input[@]}")
                point=${#input}
            fi
            ;;
        [[:print:]])
            input=("$input$REPLY" "${input[@]}")
            ((point++))
            ;;
    esac
done
